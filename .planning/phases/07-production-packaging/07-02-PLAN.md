---
phase: 07-production-packaging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yaml
autonomous: true
requirements: [IMG-06]

must_haves:
  truths:
    - "CI pipeline builds the Docker image on every push to any branch and on tags"
    - "Trivy vulnerability scan runs against the built image with CRITICAL,HIGH severity gate"
    - "SBOM is generated in SPDX-JSON format from the built image"
    - "Trivy SARIF results are uploaded to GitHub Security tab"
    - "Helm lint and golden file tests run in CI"
  artifacts:
    - path: ".github/workflows/ci.yaml"
      provides: "Complete CI pipeline with build, scan, SBOM, and Helm validation"
      contains: "aquasecurity/trivy-action"
  key_links:
    - from: ".github/workflows/ci.yaml"
      to: "docker/Dockerfile"
      via: "docker/build-push-action builds from docker/Dockerfile"
      pattern: "file: docker/Dockerfile"
    - from: ".github/workflows/ci.yaml"
      to: "helm/claude-in-a-box/"
      via: "helm lint and golden file test reference the chart"
      pattern: "helm lint helm/claude-in-a-box"
    - from: ".github/workflows/ci.yaml"
      to: "scripts/helm-golden-test.sh"
      via: "CI runs the golden file test script"
      pattern: "helm-golden-test.sh"
---

<objective>
Create the GitHub Actions CI/CD pipeline that builds the Docker image, runs Trivy vulnerability scanning, generates an SBOM, and validates the Helm chart on every push.

Purpose: Ensures every image is scanned and traceable (requirement IMG-06). CI catches regressions in both the Docker image and Helm chart templates before merge.
Output: Single CI workflow file at .github/workflows/ci.yaml.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-packaging/07-RESEARCH.md

# Dockerfile location for build context
@docker/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI workflow</name>
  <files>
    .github/workflows/ci.yaml
  </files>
  <action>
    Create the `.github/workflows/ci.yaml` following the research document pattern. Single workflow with two jobs.

    **Workflow triggers:**
    ```yaml
    on:
      push:
        branches: ["*"]
        tags: ["v*"]
      pull_request:
        branches: [main]
    ```

    **Permissions (workflow-level):**
    ```yaml
    permissions:
      contents: read
      packages: write
      security-events: write
    ```

    **Job 1: `build-scan-publish`**

    Steps (in order):
    1. `actions/checkout@v4`
    2. `docker/setup-buildx-action@v3` -- set up Buildx for caching
    3. `docker/login-action@v3` -- log in to GHCR (`registry: ghcr.io`, `username: ${{ github.actor }}`, `password: ${{ secrets.GITHUB_TOKEN }}`)
    4. `docker/metadata-action@v5` -- extract tags (sha, ref/branch, semver version, semver major.minor). Images: `ghcr.io/${{ github.repository }}`
    5. `docker/build-push-action@v6`:
       - `context: .`
       - `file: docker/Dockerfile`
       - `push: ${{ github.event_name != 'pull_request' }}` -- don't push on PRs
       - `load: ${{ github.event_name == 'pull_request' }}` -- load locally on PRs for Trivy scan
       - `tags: ${{ steps.meta.outputs.tags }}`
       - `labels: ${{ steps.meta.outputs.labels }}`
       - `cache-from: type=gha`
       - `cache-to: type=gha,mode=max`
    6. `aquasecurity/trivy-action@0.33.1`:
       - `image-ref`: Use `ghcr.io/${{ github.repository }}:sha-${{ github.sha }}` for pushes. For PRs, the metadata-action produces tags for the loaded image -- use the same SHA-based tag from local Docker daemon.
       - Actually, simplify: use the first tag from metadata output. Since `load: true` puts it in local daemon and `push: true` puts it in registry, Trivy can resolve either way. Use `${{ steps.meta.outputs.tags }}` split to get first tag, or hard-construct as `ghcr.io/${{ github.repository }}:sha-${{ github.sha }}` (Trivy will find it locally on PR, remotely on push).
       - Cleaner approach per research pitfall 4: construct image ref as `ghcr.io/${{ github.repository }}:sha-${{ github.sha }}`. On push, Trivy pulls from registry. On PR, Trivy finds it in local Docker daemon (loaded via `load: true`). Actually simpler: the metadata-action SHA tag format is `sha-<short-sha>` and `github.sha` is the full SHA. Use `${{ fromJSON(steps.meta.outputs.json).tags[0] }}` to get the first tag deterministically.
       - SIMPLEST: just hardcode image-ref pattern. For PRs with `load: true`, the image is in local Docker daemon with the metadata tags. Use a step output or just use the constructed tag.
       - Final approach: Set `image-ref` to the first tag. Add an `id: meta` to the metadata step (already there). Use: `image-ref: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}`
       - `format: sarif`
       - `output: trivy-results.sarif`
       - `severity: "CRITICAL,HIGH"`
       - `exit-code: "1"` -- fail on CRITICAL/HIGH findings
    7. `github/codeql-action/upload-sarif@v3` -- upload Trivy SARIF to GitHub Security tab
       - `if: always()` -- upload even if Trivy found vulnerabilities (so they appear in Security tab)
       - `sarif_file: trivy-results.sarif`
    8. `anchore/sbom-action@v0`:
       - `image: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}`
       - `format: spdx-json`
       - `output-file: sbom.spdx.json`
    9. `actions/upload-artifact@v4` -- upload SBOM as build artifact
       - `name: sbom`
       - `path: sbom.spdx.json`

    **Job 2: `helm-lint`** (runs in parallel with build-scan-publish)

    Steps:
    1. `actions/checkout@v4`
    2. `azure/setup-helm@v4` -- install Helm
    3. Lint: `helm lint helm/claude-in-a-box --strict`
    4. Golden file test: `bash scripts/helm-golden-test.sh`

    **Important details:**
    - The workflow name should be `CI`
    - Both jobs use `runs-on: ubuntu-latest`
    - The `helm-lint` job has NO dependency on `build-scan-publish` (they run in parallel)
    - Do NOT set `exit-code` on Trivy as a string "1" -- it should be the string `"1"` in YAML (aquasecurity/trivy-action expects string)
    - SBOM generation should have `if: always()` to run even if Trivy fails (the image is still valid, just has findings)
  </action>
  <verify>
    Validate YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yaml'))"` -- should not error.
    Check that the workflow file references the correct Dockerfile path (docker/Dockerfile), chart path (helm/claude-in-a-box), and golden test script (scripts/helm-golden-test.sh).
    Verify the file contains both job names: build-scan-publish and helm-lint.
    Verify Trivy action version is 0.33.1 and SBOM action is anchore/sbom-action@v0.
    Confirm permissions block includes packages: write and security-events: write.
  </verify>
  <done>
    .github/workflows/ci.yaml exists, is valid YAML, contains both build-scan-publish and helm-lint jobs, uses correct action versions (trivy 0.33.1, sbom-action v0, build-push-action v6), triggers on push and PR, and references the correct file paths.
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yaml` exists and is valid YAML
2. Workflow triggers on push (all branches + v* tags) and pull_request (main)
3. Build job uses docker/build-push-action@v6 with docker/Dockerfile
4. Trivy scan uses aquasecurity/trivy-action@0.33.1 with SARIF output and CRITICAL,HIGH severity
5. SBOM generated with anchore/sbom-action@v0 in spdx-json format
6. Helm lint job runs `helm lint --strict` and `scripts/helm-golden-test.sh`
7. Both jobs run in parallel (helm-lint has no needs: dependency)
</verification>

<success_criteria>
- CI workflow file exists at .github/workflows/ci.yaml and is valid YAML
- Two parallel jobs: build-scan-publish and helm-lint
- Build pushes to GHCR on push events, loads locally on PRs
- Trivy scans the image and uploads SARIF to GitHub Security tab
- SBOM generated and uploaded as build artifact
- Helm chart linted and golden file tests executed in CI
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-packaging/07-02-SUMMARY.md`
</output>
