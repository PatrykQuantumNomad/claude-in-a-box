---
phase: 04-kubernetes-manifests-rbac
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - k8s/base/00-namespace.yaml
  - k8s/base/01-serviceaccount.yaml
  - k8s/base/02-rbac-reader.yaml
  - k8s/base/03-networkpolicy.yaml
  - k8s/base/04-statefulset.yaml
autonomous: true
requirements: [K8S-01, K8S-02, K8S-03, K8S-04]

must_haves:
  truths:
    - "kubectl apply -f k8s/base/ creates all base resources without errors"
    - "StatefulSet produces pod named claude-agent-0 with stable identity"
    - "ServiceAccount claude-agent has read-only access to 14 resource types across 4 API groups"
    - "ServiceAccount cannot access secrets or perform mutations"
    - "NetworkPolicy denies all ingress and allows only DNS (53), HTTPS (443), and K8s API (6443) egress"
    - "PVC claude-data-claude-agent-0 is auto-created by volumeClaimTemplates and mounted at /app/.claude"
  artifacts:
    - path: "k8s/base/01-serviceaccount.yaml"
      provides: "Dedicated ServiceAccount for claude-agent pod"
      contains: "kind: ServiceAccount"
    - path: "k8s/base/02-rbac-reader.yaml"
      provides: "Read-only ClusterRole + ClusterRoleBinding for 14 resource types"
      contains: "claude-agent-reader"
    - path: "k8s/base/03-networkpolicy.yaml"
      provides: "Egress-only NetworkPolicy with DNS, HTTPS, and K8s API rules"
      contains: "claude-agent-netpol"
    - path: "k8s/base/04-statefulset.yaml"
      provides: "StatefulSet with headless Service, volumeClaimTemplates, SecurityContext"
      contains: "volumeClaimTemplates"
  key_links:
    - from: "k8s/base/04-statefulset.yaml"
      to: "k8s/base/01-serviceaccount.yaml"
      via: "serviceAccountName: claude-agent"
      pattern: "serviceAccountName: claude-agent"
    - from: "k8s/base/02-rbac-reader.yaml"
      to: "k8s/base/01-serviceaccount.yaml"
      via: "ClusterRoleBinding subjects referencing ServiceAccount"
      pattern: "name: claude-agent"
    - from: "k8s/base/04-statefulset.yaml"
      to: "headless Service in same file"
      via: "serviceName: claude-agent matching Service metadata.name"
      pattern: "serviceName: claude-agent"
    - from: "k8s/base/03-networkpolicy.yaml"
      to: "k8s/base/04-statefulset.yaml"
      via: "podSelector matching StatefulSet pod labels"
      pattern: "app: claude-agent"
---

<objective>
Create the base Kubernetes manifest set (ServiceAccount, RBAC reader tier, NetworkPolicy, StatefulSet with headless Service and PVC) that deploys Claude-in-a-box with correct permissions, network isolation, and persistence via a single `kubectl apply -f k8s/base/` command.

Purpose: This is the production-grade deployment foundation replacing the Phase 3 bare Pod. Every subsequent phase (testing, Helm chart) builds on these manifests.
Output: 5 YAML manifest files in k8s/base/ that deploy a complete, secure Claude-in-a-box instance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-kubernetes-manifests-rbac/04-RESEARCH.md
@kind/pod.yaml
</context>

<interfaces>
<!-- Phase 3 dev pod manifest patterns to carry forward -->

From kind/pod.yaml:
```yaml
# Pod naming convention: claude-agent-0
# Label: app: claude-agent
# Image: claude-in-a-box:dev with imagePullPolicy: IfNotPresent
# Env: CLAUDE_MODE=interactive
# Probes: exec healthcheck.sh with 10s initial, 30s period, 5s timeout
# Container needs stdin: true and tty: true
```

From 04-RESEARCH.md key patterns:
```yaml
# UID/GID: 10000 (from Phase 1 CONTEXT.md decision)
# Volume mount: /app/.claude (container home is /app)
# SecurityContext: runAsUser/runAsGroup/fsGroup all 10000, runAsNonRoot: true
# fsGroupChangePolicy: OnRootMismatch (faster startup)
# terminationGracePeriodSeconds: 60
# Resources: 512Mi/2Gi memory, 250m/2000m CPU
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create ServiceAccount and RBAC reader manifests</name>
  <files>k8s/base/00-namespace.yaml, k8s/base/01-serviceaccount.yaml, k8s/base/02-rbac-reader.yaml</files>
  <action>
Create the k8s/base/ directory structure.

**k8s/base/00-namespace.yaml:**
Create an optional namespace definition for claude-agent. Use `default` namespace. Add a comment noting Phase 7 Helm chart will parameterize this. Include the file so `kubectl apply -f k8s/base/` has a clear starting point, but set namespace to `default` so it is a no-op on most clusters. Actually -- skip creating a namespace manifest since applying to `default` namespace does not require creating it. Instead, create this as a placeholder comment file OR simply start numbering at 01. Decision: start at 01 to keep it simple -- no namespace manifest needed for default namespace.

**k8s/base/01-serviceaccount.yaml:**
Create a dedicated ServiceAccount named `claude-agent` in the `default` namespace with label `app: claude-agent`. Do NOT use the default ServiceAccount -- the research explicitly warns against this. Set `automountServiceAccountToken: true` explicitly for clarity (it is the default, but research recommends being explicit).

**k8s/base/02-rbac-reader.yaml:**
Create a multi-document YAML file (separated by `---`) containing:

1. ClusterRole `claude-agent-reader` with label `app: claude-agent` and `tier: reader`. Four rules covering all 14 required resources with ONLY get/list/watch verbs:
   - apiGroups: [""] -- pods, services, events, nodes, namespaces, configmaps, persistentvolumeclaims
   - apiGroups: ["apps"] -- deployments, statefulsets, daemonsets, replicasets
   - apiGroups: ["batch"] -- jobs, cronjobs
   - apiGroups: ["networking.k8s.io"] -- ingresses

   CRITICAL: Do NOT include `secrets` in any rule. Do NOT use wildcard verbs. Do NOT use aggregation labels that could inherit from built-in roles.

2. ClusterRoleBinding `claude-agent-reader` binding the ClusterRole to ServiceAccount `claude-agent` in namespace `default`.

Reference the exact API group mapping from 04-RESEARCH.md to avoid the silent-failure pitfall where wrong apiGroups cause permissions to not apply.
  </action>
  <verify>
    Files exist: ls k8s/base/01-serviceaccount.yaml k8s/base/02-rbac-reader.yaml
    YAML valid: kubectl apply --dry-run=client -f k8s/base/01-serviceaccount.yaml && kubectl apply --dry-run=client -f k8s/base/02-rbac-reader.yaml
    No secrets access: grep -c "secrets" k8s/base/02-rbac-reader.yaml should return 0
    All 14 resources present: grep -c "resources:" k8s/base/02-rbac-reader.yaml should show 4 rules
  </verify>
  <done>
    ServiceAccount and RBAC reader manifests exist in k8s/base/, pass dry-run validation, cover all 14 resource types across 4 API groups with only get/list/watch verbs, and explicitly exclude secrets access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NetworkPolicy and StatefulSet with headless Service</name>
  <files>k8s/base/03-networkpolicy.yaml, k8s/base/04-statefulset.yaml</files>
  <action>
**k8s/base/03-networkpolicy.yaml:**
Create an egress-only NetworkPolicy named `claude-agent-netpol` in namespace `default` with label `app: claude-agent`. Configuration:
- podSelector matching `app: claude-agent`
- policyTypes: both Ingress and Egress
- ingress: empty array (deny all inbound)
- Three egress rules:
  1. DNS: UDP and TCP port 53 (no destination restriction -- CoreDNS can be anywhere in cluster)
  2. Anthropic API: TCP port 443 to 0.0.0.0/0 (Anthropic IPs can change; port-based restriction is sufficient per research decision)
  3. K8s API server: TCP port 6443 to 0.0.0.0/0 (only API server listens on 6443)

Add a comment noting that KIND's default CNI does NOT enforce NetworkPolicy -- Phase 5 will install Calico for validation. Add a comment about the 0.0.0.0/0 CIDR decision for Anthropic API.

**k8s/base/04-statefulset.yaml:**
Create a multi-document YAML file containing:

1. Headless Service `claude-agent` with `clusterIP: None`, selector `app: claude-agent`, and a placeholder port (port 80, name "placeholder"). Add comment explaining this is required for StatefulSet DNS identity. Namespace `default`, label `app: claude-agent`.

2. StatefulSet `claude-agent` in namespace `default` with:
   - serviceName: claude-agent (must match headless Service name)
   - replicas: 1
   - selector and template labels: app: claude-agent
   - serviceAccountName: claude-agent
   - terminationGracePeriodSeconds: 60
   - Pod-level securityContext: runAsUser: 10000, runAsGroup: 10000, fsGroup: 10000, fsGroupChangePolicy: OnRootMismatch, runAsNonRoot: true
   - Single container `claude-agent`:
     - image: claude-in-a-box:dev (imagePullPolicy: IfNotPresent)
     - env: CLAUDE_MODE=interactive
     - volumeMounts: claude-data at /app/.claude
     - livenessProbe: exec healthcheck.sh, initialDelaySeconds 10, periodSeconds 30, timeoutSeconds 5
     - readinessProbe: exec healthcheck.sh, initialDelaySeconds 10, periodSeconds 30, timeoutSeconds 5
     - stdin: true, tty: true
     - resources: requests 512Mi/250m, limits 2Gi/2000m
   - volumeClaimTemplates: claude-data with ReadWriteOnce access, 1Gi storage request

   Carry forward all probe settings and container config from kind/pod.yaml. Add SecurityContext, resources, and volumeClaimTemplates which are new for Phase 4.
  </action>
  <verify>
    Files exist: ls k8s/base/03-networkpolicy.yaml k8s/base/04-statefulset.yaml
    YAML valid: kubectl apply --dry-run=client -f k8s/base/03-networkpolicy.yaml && kubectl apply --dry-run=client -f k8s/base/04-statefulset.yaml
    NetworkPolicy has 3 egress rules: grep -c "port:" k8s/base/03-networkpolicy.yaml should be 5 (53 UDP, 53 TCP, 443, 6443, plus placeholder in Service -- actually just check egress rules)
    StatefulSet references ServiceAccount: grep "serviceAccountName: claude-agent" k8s/base/04-statefulset.yaml
    Volume mount correct: grep "mountPath: /app/.claude" k8s/base/04-statefulset.yaml
    fsGroup set: grep "fsGroup: 10000" k8s/base/04-statefulset.yaml
    Headless Service present: grep "clusterIP: None" k8s/base/04-statefulset.yaml
    Full dry-run of all base manifests: kubectl apply --dry-run=client -f k8s/base/
  </verify>
  <done>
    NetworkPolicy and StatefulSet manifests exist, pass dry-run validation. NetworkPolicy denies all ingress and allows DNS (53), HTTPS (443), and K8s API (6443) egress. StatefulSet creates pod claude-agent-0 with PVC auto-provisioned via volumeClaimTemplates, mounted at /app/.claude with fsGroup 10000 for non-root access. All base manifests validate together with `kubectl apply --dry-run=client -f k8s/base/`.
  </done>
</task>

</tasks>

<verification>
1. All 4 manifest files exist in k8s/base/ with numbered prefixes
2. `kubectl apply --dry-run=client -f k8s/base/` succeeds for all files
3. No secrets mentioned in RBAC rules
4. All 14 resource types covered in reader ClusterRole
5. NetworkPolicy has empty ingress array and 3 egress rules
6. StatefulSet references claude-agent ServiceAccount
7. volumeClaimTemplates defines claude-data PVC
8. SecurityContext sets UID/GID/fsGroup to 10000
</verification>

<success_criteria>
- `kubectl apply --dry-run=client -f k8s/base/` validates all manifests without errors
- Reader ClusterRole covers exactly 14 resources (pods, services, events, nodes, namespaces, configmaps, persistentvolumeclaims, deployments, statefulsets, daemonsets, replicasets, jobs, cronjobs, ingresses) with only get/list/watch
- NetworkPolicy blocks all ingress, allows egress on ports 53 (UDP+TCP), 443 (TCP), 6443 (TCP)
- StatefulSet creates claude-agent-0 with PVC at /app/.claude, fsGroup 10000, and resource limits
</success_criteria>

<output>
After completion, create `.planning/phases/04-kubernetes-manifests-rbac/04-01-SUMMARY.md`
</output>
